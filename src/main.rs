use cranelift::prelude::*;
use cranelift_jit::{JITBuilder, JITModule};
use cranelift_module::{Module, Linkage};

macro_rules! define_and_register_math_fns {
    // creating a function with the extern C tag and then adding it as a symbol in our module builder
    ($builder:ident, [$(($name:ident, $ret:ty, [$($arg:ident : $typ:ty),*], $body:block)),* $(,)?]) => {
        $(
            extern "C" fn $name($($arg: $typ),*) -> $ret {
                $body
            }
            $builder.symbol(stringify!($name), $name as *const u8);
        )*
    };
}

macro_rules! call_imported_func {
    // creates function with the appropriate number of params and ret values
    ($builder:expr, $module:expr, $name:expr, [$($arg:expr),*], [$($ty:expr),*], $ret_ty:expr) => {{
        let mut sig = $module.make_signature();

        $(
            sig.params.push(AbiParam::new($ty));
        )*

        sig.returns.push(AbiParam::new($ret_ty));

        let func = $module
            .declare_function($name, Linkage::Import, &sig)
            .unwrap();

        let local = $module.declare_func_in_func(func, $builder.func);
        let args = &[$($arg),*];
        let call = $builder.ins().call(local, args);
        $builder.inst_results(call)[0]
    }};
}

// building block for our AST
#[derive(Clone, Debug)]
pub enum Node {
    X,
    Y,
    Number(f32),
    Add(Box<Node>, Box<Node>),
    Mul(Box<Node>, Box<Node>),
    Sin(Box<Node>),
    Cos(Box<Node>),
}

fn codegen_node(
    builder: &mut FunctionBuilder,
    module: &mut JITModule,
    node: &Node,
    x: Value,
    y: Value,
) -> Value {
    match node {
        Node::X => x,
        Node::Y => y,
        Node::Number(val) => builder.ins().f32const(Ieee32::with_float(*val)),
        Node::Add(a, b) => {
            let lhs = codegen_node(builder, module, a, x, y);
            let rhs = codegen_node(builder, module, b, x, y);
            call_imported_func!(builder, module, "my_add", [lhs, rhs],  [types::F32, types::F32], types::F32)
        }
        Node::Mul(a, b) => {
            let lhs = codegen_node(builder, module, a, x, y);
            let rhs = codegen_node(builder, module, b, x, y);
            call_imported_func!(builder, module, "my_mul", [lhs, rhs],  [types::F32, types::F32], types::F32)
        }
        Node::Sin(a) => {
            let arg = codegen_node(builder, module, a, x, y);
            call_imported_func!(builder, module, "my_sin", [arg], [types::F32], types::F32)
        }
        Node::Cos(a) => {
            let arg = codegen_node(builder, module, a, x, y);
            call_imported_func!(builder, module, "my_cos", [arg], [types::F32], types::F32)
        }
    }
}


// using rust closures with extern C tag rather than directly writing the cranelift IR
// the machine code generated by the JIT compilation then matches what LLVM would've outputted
// there is some discrepancy with how cranelift IR is converted to machine code compared to LLVM
// issues stemmed from floating point math operations from when i was experimenting
fn build_jit_function(ast: &Node) -> Box<dyn Fn(f32, f32) -> f32> {
    let mut builder = JITBuilder::new(cranelift_module::default_libcall_names())
        .expect("Failed to create JITBuilder");

    define_and_register_math_fns!(builder, [
        (my_sin, f32, [x: f32], { x.sin() }),
        (my_cos, f32, [x: f32], { x.cos() }),
        (my_add, f32, [a: f32, b: f32], { (a + b) / 2.0 }),
        (my_mul, f32, [a: f32, b: f32], { a * b }),
    ]);

    let mut module = JITModule::new(builder);
    let mut sig = module.make_signature();
    sig.params.push(AbiParam::new(types::F32));
    sig.params.push(AbiParam::new(types::F32));
    sig.returns.push(AbiParam::new(types::F32));

    let func_id = module
        .declare_function("jit_func", Linkage::Export, &sig)
        .unwrap();

    let mut ctx = module.make_context();
    ctx.func.signature = sig;

    let mut builder_ctx = FunctionBuilderContext::new();
    let mut fb = FunctionBuilder::new(&mut ctx.func, &mut builder_ctx);
    let block = fb.create_block();

    fb.append_block_params_for_function_params(block);
    fb.switch_to_block(block);
    fb.seal_block(block);

    let x = fb.block_params(block)[0];
    let y = fb.block_params(block)[1];
    let result = codegen_node(&mut fb, &mut module, ast, x, y);
    fb.ins().return_(&[result]);
    fb.finalize();

    println!("{}", ctx.func.display());
    module.define_function(func_id, &mut ctx).unwrap();
    module.clear_context(&mut ctx);
    let _ = module.finalize_definitions();

    let code = module.get_finalized_function(func_id);
    let fn_ptr = unsafe { std::mem::transmute::<_, fn(f32, f32) -> f32>(code) };
    Box::new(fn_ptr)
}

fn main() {
    let ast = Node::Add(Box::new(Node::X), Box::new(Node::Sin(Box::new(Node::Y))));
    let jit_fn = build_jit_function(&ast);
    println!("f(1.0, 0.5) = {}", jit_fn(1.0, 0.5));
}